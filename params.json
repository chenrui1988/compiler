{"name":"Compiler","tagline":"Lex/Yacc  IA32-code compiler example","body":"# Lex/Yacc Compiler\r\n\r\n> This is a simple example to show how to use Lex/Yacc  to generate IA32 code\r\n\r\n## Overview\r\n* [Operating Environment](#user-content-operating-environment)\r\n* [Program Grammar](#user-content-program-grammar)\r\n* [Using Help](#user-content-using-help)\r\n* [Code Files](#user-content-code-files)\r\n* [Compilation Sequence](#user-content-compilation-sequence)\r\n\r\n####Operating Environment\r\n- OS X 10.9.2\r\n- Lex, Bison, Gcc\r\n\r\n#### Program Grammar\r\n\r\n##### Variable Type\r\n ```  java\r\n    s : String <- \"abcd\";\r\n    x : Int;\r\n    x : Int []; \r\n```\r\n##### Variable Declaration\r\n```  java\r\n    y : Int ;\r\n    x : Int -> 1;\r\n```\r\n##### Assignment Statement\r\n```  java\r\n    x -> 1;\r\n```\r\n##### If Statement\r\n```  java\r\n    if \r\n        a < 2 \r\n    then \r\n        1 \r\n    else \r\n        factorial(a-1) + factorial(a-2)\r\n    fi\r\n```\r\n##### While Statement\r\n```  java\r\n    while i < size loop {\r\n    \r\n    } pool\r\n```\r\n##### Let Statement\r\n```  java\r\n    let i : Int, small : Int in {\r\n    \r\n    } tel\r\n```\r\n##### System Declaration \r\n```  java\r\n    out_string(\"> \");\r\n    x <- in_int();\r\n    out_int(x*2+(y-4));\r\n```\r\n##### Function Declaration \r\n```  java\r\n    factorial(a: Int) : Int {\r\n    \r\n    }\r\n```\r\n##### Class Declaration \r\n```  java\r\n    class Main {\r\n    \r\n    }\r\n```\r\n##### A Program sample\r\n```  java\r\n    class Main {\r\n        s : String <- \"abcd\";\r\n        x : Int;\r\n        y : Int <- 10;\r\n        main () : Int {\r\n          x <- in_int();\r\n          out_string(\"test\");\r\n          out_string(s);\r\n          out_int(x*2+(y-4))\r\n        };\r\n    }\r\n```\r\nIt's also has a main class in a file and a main function in a class, When compiler success, the program will run start by main function. The compiler can check the symbol scope, support function call, but now it can't support type check and It's not an object-oriented design\r\n\r\n#### Using Help\r\n1. build Lex/Yacc, Will Generate uncool.pgm program\r\n```  bash\r\n    make\r\n```\r\n2. parse the uc  to IA32 code, execute the command\r\n```  bash\r\n \t./uncool.pgm uncool.uc >uncool.s \r\n```\r\n3. Assembly the IA32 code to executable program,execute the command\r\n```  bash\r\n    gcc –m32 uncool.s –o uncool\r\n```\r\n4. execute the program you will see the result of this program result.\r\n```  bash\r\n    ./uncool\r\n```\r\n\r\n#### Code Files\r\n1. Uncool.l，Uncool.y, Uclib.h  \r\n    Lex/Yacc code common function and structure\r\n2. symbol_table.h symbol_table.c  \r\n    symbol_table implement storage symbol in the LinkList\r\n3. stack.h stack.c  \r\n    symbol_table stack implement store symbol_table in stack\r\n4. uccompiler.c  \r\n    the main parse program, transition the Uc code to IA32 code\r\n\r\n#### Compilation Sequence\r\n\r\n![Alt text](http://d.pcs.baidu.com/thumbnail/8dfdac6cd27588a6599662a338fee29a?fid=2150734521-250528-406344211216901&time=1417179600&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-2UjbiSBH%2BVWvBM9vXqpVFDpfOLI%3D&rt=sh&expires=2h&r=454594510&sharesign=unknown&size=c710_u500&quality=100)\r\n\r\n1. Uclib.c / Uncool.y syntax analyzer program scan the uncool code to generate syntax tree. The tree data is store in the nodeType strut. The nodeType strut is a tree data strut, It contains all syntax nodes and those relationship.\r\n2. Then we will call ex function in the Uncool.y, when complete scan code, you can see the call function code in the Uncool.y , lineno 70, It will be executed when complete scan.\r\n3. The ex function is in the uccompiler.c file, It was used transition the Uc code to IA32 code, It read all node in the syntax tree and transition the operation to IA32 code.\r\n4. The symbol_table and stack is used to record the program variables\r\nStack.h, Stack.c has define a linked list data structure， It was used to store symbol_table. When The code run into the class , function or let code, we will generate a symbol_table data and put it into Stack, The head of Stack is the current scope of the symbol table, when run out the class, function or let code, we wil let symbol table out the stack and remove the class, function or let’s variable. symbol_table is a linked list data structure too, It is used to store current scope’s symbol variable, when we use a variable , or a function, we will find from here\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}